const { db } = require('./database');
const { v4: uuidv4 } = require('uuid');
const fs = require('fs');
const path = require('path');

class ReportService {
  async getAllReports(filters = {}) {
    return new Promise((resolve, reject) => {
      let query = `
        SELECT r.*, t.domain, t.name as target_name 
        FROM reports r 
        JOIN targets t ON r.target_id = t.id 
        WHERE 1=1
      `;
      const params = [];

      if (filters.status) {
        query += ' AND r.status = ?';
        params.push(filters.status);
      }

      if (filters.targetId) {
        query += ' AND r.target_id = ?';
        params.push(filters.targetId);
      }

      query += ' ORDER BY r.created_at DESC';

      db.all(query, params, (err, rows) => {
        if (err) {
          reject(err);
        } else {
          resolve(rows);
        }
      });
    });
  }

  async generateReport(targetId, template) {
    const id = uuidv4();
    const target = await this.getTargetById(targetId);
    if (!target) {
      throw new Error('Target not found');
    }

    const vulnerabilities = await this.getVulnerabilitiesByTarget(targetId);
    const reconResults = await this.getReconResults(targetId);

    const reportContent = await this.generateReportContent(target, vulnerabilities, reconResults, template);

    return new Promise((resolve, reject) => {
      db.run(
        'INSERT INTO reports (id, target_id, title, content, status) VALUES (?, ?, ?, ?, ?)',
        [id, targetId, `${template} Report - ${target.domain}`, reportContent, 'draft'],
        function(err) {
          if (err) {
            reject(err);
          } else {
            resolve({ 
              id, 
              targetId, 
              title: `${template} Report - ${target.domain}`, 
              content: reportContent, 
              status: 'draft' 
            });
          }
        }
      );
    });
  }

  async generateReportContent(target, vulnerabilities, reconResults, template) {
    const templatePath = path.join(__dirname, '../../templates', `${template}.md`);
    
    if (templatePath) {
      try {
        let templateContent = fs.readFileSync(templatePath, 'utf8');
        
        // Replace placeholders
        templateContent = templateContent.replace(/\[TARGET_NAME\]/g, target.domain);
        templateContent = templateContent.replace(/\[DATE\]/g, new Date().toISOString().split('T')[0]);
        templateContent = templateContent.replace(/\[TOTAL_SUBDOMAINS\]/g, reconResults.totalSubdomains || 0);
        templateContent = templateContent.replace(/\[TOTAL_VULNS\]/g, vulnerabilities.length);
        
        // Add vulnerability details
        const vulnSection = vulnerabilities.map(vuln => `
## ${vuln.title}
**Severity:** ${vuln.severity}  
**CWE:** ${vuln.cwe_id || 'N/A'}  
**Status:** ${vuln.status}

### Description
${vuln.description}

### Proof of Concept
\`\`\`
${vuln.poc || 'N/A'}
\`\`\`

---
        `).join('\n');

        templateContent = templateContent.replace(/\[VULNERABILITIES\]/g, vulnSection);
        
        return templateContent;
      } catch (error) {
        console.error('Template error:', error);
      }
    }

    // Fallback simple report
    return `# Bug Bounty Report

## Target: ${target.domain}
**Date:** ${new Date().toISOString().split('T')[0]}

## Executive Summary
Total vulnerabilities found: ${vulnerabilities.length}

## Findings

${vulnerabilities.map(vuln => `
### ${vuln.title} (${vuln.severity})
${vuln.description}

**Proof of Concept:**
\`\`\`
${vuln.poc || 'N/A'}
\`\`\`
`).join('\n')}

---
Generated by Bug Bounty System
    `;
  }

  async getReportById(reportId) {
    return new Promise((resolve, reject) => {
      const query = `
        SELECT r.*, t.domain, t.name as target_name 
        FROM reports r 
        JOIN targets t ON r.target_id = t.id 
        WHERE r.id = ?
      `;
      
      db.get(query, [reportId], (err, row) => {
        if (err) {
          reject(err);
        } else {
          resolve(row);
        }
      });
    });
  }

  async updateReport(reportId, updateData) {
    const { title, content, status } = updateData;
    
    return new Promise((resolve, reject) => {
      db.run(
        'UPDATE reports SET title = ?, content = ?, status = ?, submitted_at = ? WHERE id = ?',
        [title, content, status, status === 'submitted' ? new Date().toISOString() : null, reportId],
        function(err) {
          if (err) {
            reject(err);
          } else if (this.changes === 0) {
            reject(new Error('Report not found'));
          } else {
            resolve({ id: reportId, ...updateData });
          }
        }
      );
    });
  }

  async deleteReport(reportId) {
    return new Promise((resolve, reject) => {
      db.run(
        'DELETE FROM reports WHERE id = ?',
        [reportId],
        function(err) {
          if (err) {
            reject(err);
          } else if (this.changes === 0) {
            reject(new Error('Report not found'));
          } else {
            resolve(true);
          }
        }
      );
    });
  }

  async exportReport(reportId, format) {
    const report = await this.getReportById(reportId);
    if (!report) {
      throw new Error('Report not found');
    }

    let contentType, filename, content;

    switch (format.toLowerCase()) {
      case 'json':
        contentType = 'application/json';
        filename = `${report.target_name}-report.json`;
        content = JSON.stringify(report, null, 2);
        break;
      case 'txt':
        contentType = 'text/plain';
        filename = `${report.target_name}-report.txt`;
        content = report.content;
        break;
      case 'pdf':
        // For now, return markdown
        contentType = 'text/markdown';
        filename = `${report.target_name}-report.md`;
        content = report.content;
        break;
      default:
        contentType = 'text/markdown';
        filename = `${report.target_name}-report.md`;
        content = report.content;
    }

    return { contentType, filename, content };
  }

  async getTargetById(targetId) {
    return new Promise((resolve, reject) => {
      db.get(
        'SELECT * FROM targets WHERE id = ?',
        [targetId],
        (err, row) => {
          if (err) {
            reject(err);
          } else {
            resolve(row);
          }
        }
      );
    });
  }

  async getVulnerabilitiesByTarget(targetId) {
    return new Promise((resolve, reject) => {
      db.all(
        'SELECT * FROM vulnerabilities WHERE target_id = ? ORDER BY severity DESC, created_at DESC',
        [targetId],
        (err, rows) => {
          if (err) {
            reject(err);
          } else {
            resolve(rows);
          }
        }
      );
    });
  }

  async getReconResults(targetId) {
    // Get recon results from the latest successful job
    return new Promise((resolve, reject) => {
      db.get(
        'SELECT results FROM recon_jobs WHERE target_id = ? AND status = "completed" ORDER BY completed_at DESC LIMIT 1',
        [targetId],
        (err, row) => {
          if (err) {
            reject(err);
          } else if (row && row.results) {
            try {
              const results = JSON.parse(row.results);
              resolve({
                totalSubdomains: results.outputFiles?.length || 0,
                ...results
              });
            } catch (e) {
              resolve({ totalSubdomains: 0 });
            }
          } else {
            resolve({ totalSubdomains: 0 });
          }
        }
      );
    });
  }
}

module.exports = new ReportService();